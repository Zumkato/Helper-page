"""State management for projects and related entities."""

from __future__ import annotations

from typing import Any, List

from sqlmodel import select

from .app_state import AppState
from .. import models
from ..db import get_session
from ..services import executor, llm
from ..utils.markdown import sanitize_markdown


class ProjectState(AppState):
    """Application state that handles project CRUD and service calls."""

    projects: List[dict] = []
    current_project: dict | None = None
    notes: List[dict] = []
    runs: List[dict] = []
    # In-memory attack chain data for the builder UI. Each step is a string
    # description. Persistence is a future enhancement.
    chain_steps: List[str] = []
    # Latest suggestion text returned from the LLM.
    suggestions: str = ""
    error: str | None = None

    async def load_projects(self) -> List[dict]:
        """Retrieve all projects from the database."""
        self.set_loading(True)
        self.error = None
        try:
            with get_session() as session:
                results = session.exec(select(models.Project)).all()
                self.projects = [p.model_dump() for p in results]
                return self.projects
        except Exception as exc:  # pragma: no cover - best effort
            self.error = str(exc)
            raise
        finally:
            self.set_loading(False)

    async def load_project(self, project_id: int) -> None:
        """Load a single project and its related data."""
        self.set_loading(True)
        self.error = None
        try:
            with get_session() as session:
                project = session.get(models.Project, project_id)
                if project is None:
                    self.error = "Project not found"
                    return
                self.current_project = project.model_dump()
                notes = session.exec(
                    select(models.Note).where(models.Note.project_id == project_id)
                ).all()
                runs = session.exec(
                    select(models.Run).where(models.Run.project_id == project_id)
                ).all()
                self.notes = [
                    {**n.model_dump(), "content": sanitize_markdown(n.content)}
                    for n in notes
                ]
                self.runs = [r.model_dump() for r in runs]
        finally:
            self.set_loading(False)

    async def create_project(self, name: str, description: str | None = None) -> dict:
        """Create a new project and persist it."""
        self.set_loading(True)
        try:
            project = models.Project(name=name, description=description)
            with get_session() as session:
                session.add(project)
                session.commit()
                session.refresh(project)
            data = project.model_dump()
            self.projects.append(data)
            return data
        finally:
            self.set_loading(False)

    async def handle_create_project(self, form_data: dict) -> None:
        """Form handler for creating a project from page input."""
        name = form_data.get("name", "").strip()
        description = form_data.get("description")
        if not name:
            self.add_toast("Name is required")
            return
        await self.create_project(name=name, description=description)
        self.add_toast("Project created")

    async def add_note(self, project_id: int, content: str) -> dict:
        """Add a note to a project.

        Note content is sanitized before being persisted to prevent injection of
        unsafe HTML.  The sanitized version is also returned and stored in local
        state.
        """
        cleaned = sanitize_markdown(content)
        note = models.Note(project_id=project_id, content=cleaned)
        with get_session() as session:
            session.add(note)
            session.commit()
            session.refresh(note)
        data = note.model_dump()
        data["content"] = sanitize_markdown(data["content"])
        self.notes.append(data)
        return data

    async def run_command(self, project_id: int, command: str) -> dict:
        """Execute an allowlisted command via the executor service."""
        output = await executor.run(command)
        run = models.Run(project_id=project_id, command=command, output=output)
        with get_session() as session:
            session.add(run)
            session.commit()
            session.refresh(run)
        data = run.model_dump()
        self.runs.append(data)
        return data

    async def handle_add_note(self, form_data: dict) -> None:
        """Form handler to create a note for the current project."""
        content = form_data.get("content", "").strip()
        if not content:
            self.add_toast("Content is required")
            return
        if not self.current_project:
            self.add_toast("No project loaded")
            return
        await self.add_note(self.current_project["id"], content)
        self.add_toast("Note added")

    async def handle_run_command(self, form_data: dict) -> None:
        """Form handler to execute a command for the current project."""
        command = form_data.get("command", "").strip()
        if not command:
            self.add_toast("Command is required")
            return
        if not self.current_project:
            self.add_toast("No project loaded")
            return
        try:
            await self.run_command(self.current_project["id"], command)
            self.add_toast("Command executed")
        except ValueError as exc:
            self.add_toast(str(exc))

    # ------------------------------------------------------------------
    # Attack chain helpers

    def add_chain_step(self, action: str) -> None:
        """Append a new step to the in-memory attack chain."""
        action = action.strip()
        if action:
            self.chain_steps.append(action)

    def reorder_chain_steps(self, order: List[int]) -> None:
        """Reorder steps based on an index list from the UI."""
        self.chain_steps = [self.chain_steps[i] for i in order]

    async def handle_add_chain_step(self, form_data: dict) -> None:
        """Form handler that adds a new attack chain step."""
        self.add_chain_step(form_data.get("action", ""))

    async def handle_generate_suggestions(self, form_data: dict) -> None:
        """Fetch LLM-based chain step suggestions for a given prompt."""
        prompt = form_data.get("prompt", "").strip()
        if not prompt:
            self.add_toast("Prompt is required")
            return
        self.set_loading(True)
        try:
            self.suggestions = await self.suggest_chain_steps(prompt)
        finally:
            self.set_loading(False)

    async def suggest_chain_steps(self, prompt: str) -> str:
        """Get attack chain step suggestions from the LLM service."""
        provider = llm.EchoLLM()
        return await provider.generate(prompt)